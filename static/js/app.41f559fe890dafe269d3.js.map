{"version":3,"sources":["webpack:///./src/lib/simplify.js","webpack:///./src/appState.js","webpack:///./src/lib/createSVGContext.js","webpack:///./src/lib/createHeightMapRenderer.js","webpack:///./src/config.js","webpack:///./src/lib/indexPolygon.js","webpack:///./src/getRegionElevation.js","webpack:///./src/main.js"],"names":["getSqSegDist","p","p1","p2","x","y","dx","dy","t","simplifyDouglasPeucker","points","sqTolerance","last","length","simplified","simplifyDPStep","first","index","maxSqDist","i","sqDist","push","simplify","tolerance","highestQuality","undefined","point","prevPoint","newPoints","len","simplifyRadialDist","module","exports","default","__WEBPACK_IMPORTED_MODULE_0_tinycolor2__","__webpack_require__","__WEBPACK_IMPORTED_MODULE_0_tinycolor2___default","n","appState","angle","currentState","lineDensity","lineWidth","smoothSteps","mapOpacity","heightScale","oceanLevel","aboutVisible","error","zazzleLink","generatingPreview","settingsOpen","shouldDraw","renderProgress","showBoundaryDetails","selectedBoundShortName","boundarySearchQuery","boundarySearchResults","bounds","mapName","showLess","showThemeDetails","selectedTheme","themes","value","name","backgroundColor","lineBackground","lineColor","theme","find","tinycolor","toRgb","createSVGContext","width","height","allPaths","currentPath","background","attribution","api","serialize","map","join","fillRect","fillStyle","beginPath","segments","lastCommand","stroke","lineCount","lineTo","prefix","round","moveTo","strokeString","lineWidthString","isEmpty","setStroke","strokeStyle","setLineWidth","customLineWidth","createPath","appendLabels","labels","text","label","insecurelyEscaped","replace","leftOffset","right","bottomOffset","bottom","upScale","fontSize","fontFamily","color","forEach","item","Math","createHeightMapRenderer","regionInfo","canvas","renderHandle","trueWindowHeight","render","cancel","cancelAnimationFrame","settings","message","parse_float_default","parseFloat","style","opacity","ctx","getContext","lineStroke","getColor","lineFill","resHeight","windowHeight","resWidth","window","innerWidth","rowCount","scale","_regionInfo$getAllHei","getAllHeightData","minHeight","maxHeight","rowWithHighestPoint","iteratorSettings","includeRowIndex","stepSize","start","floor","stop","step","createRegionIterator","heightRange","lastLine","lastRow","columnHeights","innerHeight","svg","Float32Array","row","drawSVGLine","isEven","getHeightAtPoint","fY","renderSVGRows","clearRect","renderRows","now","performance","drawPolyLine","elapsed","requestAnimationFrame","getSmoothRange","wasVisible","lastRenderedColumnHeight","isVisible","min","smoothRange","max","closePath","fill","windowSize","result","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","to","count","sum","j","smoothHeight","useHex","hex","r","g","b","a","hexValue","toString","MAPBOX_TOKEN","inside","require","indexPolygon","nominatimResponse","yes","boundingbox","checkForGeo","geojson","poly","coordinates","type","Error","polygons","polygon","final","lonLat","checkInsideGeoJSON","isInsideBoundingBox","apiURL","imageCache","map_default","getRegionElevation","doneCallback","progress","_map$transform","transform","tileSize","tileZoom","zoomPower","pow","coveringTiles","minzoom","maxzoom","tileBounds","reduce","tile","canonical","minX","minY","maxX","maxY","Infinity","widthInTiles","heightInTiles","bearing","se","getBounds","getSouthEast","lat","PI","atan","exp","tile2lat","project","document","createElement","total","advanceProgress","heightsHandle","isCancelled","tilesToLoad","request","url","z","getRequestForTile","cachedImage","get","promise_default","resolve","img","Image","onload","onerror","crossOrigin","src","set","loadImage","then","image","drawImage","catch","finally","all","canvasWidth","data","getImageData","windowWidth","allHeights","done","timeQuota","lastY","insideMask","collectHeights","startTime","rowsProcessed","getHeight","lngLat","pointLocation","lng","xTile","l","lng2tile","xOffset","yTile","log","tan","cos","lat2tile","yOffset","yC","xC","R","G","B","decodeHeight","visibleHeights","completed","MapboxGeocoder","addEventListener","e","gtag","exDescription","filename","lineno","description","fatal","bind","oe","heightMapRenderer","regionBuilder","isListening","listenToEvents","newIsListening","on","updateMapWhenIdle","hideHeights","off","once","updateMap","getHeightMapCanvas","heightMapCanvas","ensureSizeIsUpdated","display","sizeDirty","updateSizes","dimensions","left","top","mapContainer","querySelector","px","resize","init","mapboxgl","accessToken","Map","trackResize","container","minZoom","center","zoom","hash","addControl","NavigationControl","showCompass","getBearing","touchZoomRotate","disableRotation","redraw","exportToSVG","assign_default","setBounds","display_name","split","bbox","fitBounds","animate","padding"],"mappings":"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","file":"static/js/app.41f559fe890dafe269d3.js","sourcesContent":["/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n\n (c) 2020, Andrei Kashcha - replaced .x and .y as recommended in original code\n*/\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1[0] - p2[0],\n        dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1[0],\n        y = p1[1],\n        dx = p2[0] - x,\n        dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n// export as AMD module / Node module / browser or worker variable\nmodule.exports = simplify;\nmodule.exports.default = simplify;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/simplify.js","import tinycolor from 'tinycolor2';\n\nconst appState = {\n  angle: 0,\n  currentState: 'intro',\n  lineDensity: 28,\n  lineWidth: 1,\n  smoothSteps: 1,\n  mapOpacity: 100,\n  heightScale: 42,\n  oceanLevel: 0,\n  aboutVisible: false,\n  error: null,\n  zazzleLink: null,\n  generatingPreview: false,\n  settingsOpen: false,\n  shouldDraw: false,\n  renderProgress: null,\n  showBoundaryDetails: false,\n  selectedBoundShortName: null,\n  boundarySearchQuery: '',\n  boundarySearchResults: [],\n  bounds: null,\n  mapName: null,\n  showLess: false,\n  showThemeDetails: false,\n  selectedTheme: 'beige',\n  themes: [{\n    value: 'beige',\n    name: 'beige',\n    backgroundColor: '#F7F2E8',\n    lineBackground: '#F7F2E8',\n    lineColor: 'rgb(22, 22, 22)'\n  }, {\n    value: 'dark', \n    name: 'dark',\n    backgroundColor: '#3C3D3D',\n    lineBackground: '#3C3D3D',\n    lineColor: '#ffffff'\n  }, {\n    value: 'blue',\n    name: 'blue',\n    backgroundColor: '#101E33',\n    lineBackground: '#101E33',\n    lineColor: '#D1D8E3'\n  }, {\n    value: 'emerald',\n    name: 'emerald',\n    backgroundColor: '#182217',\n    lineBackground: '#182217',\n    lineColor: '#2CFA8A',\n  }, {\n    value: 'white', \n    name: 'white',\n    backgroundColor: '#ffffff',\n    lineBackground: '#ffffff',\n    lineColor: '#000000'\n  }],\n};\n\n// TODO: This should probably live in App.vue\nlet theme = appState.themes.find(theme => theme.name === appState.selectedTheme);\nappState.backgroundColor = tinycolor(theme.backgroundColor).toRgb();\nappState.lineBackground = tinycolor(theme.lineBackground).toRgb();\nappState.lineColor = tinycolor(theme.lineColor).toRgb();\n\nexport default appState;\n\n\n// WEBPACK FOOTER //\n// ./src/appState.js","/**\n * Basic proxy that acts like a 2d canvas context and renders paths\n * to SVG string. Supports limited subset of operations.\n */\nexport default function createSVGContext(width, height) {\n  let allPaths = [];\n  let currentPath;\n  let background = '';\n  let attribution = '';\n\n  let api = {\n    serialize,\n    fillRect,\n    beginPath,\n    lineTo,\n    moveTo,\n    stroke,\n    lineWidth: 1,\n    strokeStyle: '#161616',\n    fillStyle: 'white',\n\n    // TODO: this is not consistent with canvas context.\n    appendLabels,\n  }\n\n  return api;\n\n  function fillRect(x, y, width, height) {\n    background = `<rect id=\"background\" fill=\"${api.fillStyle}\" x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\"></rect>`;\n  }\n\n  function appendLabels(labels) {\n    if (!labels) return;\n    let text = [];\n    labels.map(label => {\n      if (!label.text) return;\n      let insecurelyEscaped = label.text\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n      \n      // Note: this is not 100% accurate, might need to be fixed eventually\n      let bounds = label.bounds;\n      let leftOffset = bounds.right;\n      let bottomOffset = bounds.bottom;\n      let upScale = label.fontSize;\n\n      let fontFamily = label.fontFamily.replace(/\"/g, '\\'');\n      return `<text text-anchor=\"end\" x=\"${leftOffset}\" y=\"${bottomOffset}\" fill=\"${label.color}\" font-family=\"${fontFamily}\" font-size=\"${upScale}\">${insecurelyEscaped}</text>`\n    }).forEach(item => {\n      if (!item) return;\n      text.push(item);\n    });\n    if (text.length > 0) {\n      attribution = `<g id='labels'>${text.join('\\n')}</g>`;\n    }\n  }\n\n  function serialize() {\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: https://github.com/anvaka/peak-map  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n   viewBox=\"0 0 ${width} ${height}\">\n${background}\n<g id='paths'>\n   ${allPaths.map(x => x.serialize()).join('\\n')}\n</g>\n${attribution}\n</svg>`\n  }\n\n  function beginPath() {\n    currentPath = createPath();\n  }\n\n  function lineTo(x, y) {\n    currentPath.lineTo(x, y);\n  }\n\n  function moveTo(x, y) {\n    currentPath.moveTo(x, y);\n  }\n\n  function stroke() {\n    if (currentPath && !currentPath.isEmpty()) {\n      if (api.strokeStyle) {\n        currentPath.setStroke(api.strokeStyle);\n      }\n      if (api.lineWidth) {\n        currentPath.setLineWidth(api.lineWidth);\n      }\n      allPaths.push(currentPath);\n    }\n  }\n}\n\nfunction createPath() {\n  let segments = [];\n  let lastCommand = null;\n  let stroke, lineWidth;\n  let lineCount = 0;\n\n  return {\n    lineTo,\n    moveTo,\n    serialize,\n    isEmpty() {\n      return lineCount === 0;\n    },\n    setStroke(strokeStyle) {\n      stroke = strokeStyle;\n    },\n    setLineWidth(customLineWidth) {\n      lineWidth = customLineWidth;\n    },\n  }\n\n  function serialize() {\n    let strokeString = stroke ? `stroke=\"${stroke}\" ` : '';\n    let lineWidthString = lineWidth !== 1 ? `stroke-width=\"${lineWidth}\"` : '';\n    return `<path d=\"${segments.join(' ')}\" fill=\"none\" ${strokeString}${lineWidthString}></path>`\n  }\n\n  function moveTo(x, y) {\n    let prefix = lastCommand === 'M' ? '' : 'M';\n    segments.push(`${prefix}${round(x)} ${round(y)}`)\n    lastCommand = 'M';\n  }\n\n  function lineTo(x, y) {\n    lineCount += 1;\n    let prefix = lastCommand === 'L' ? '' : 'L';\n    segments.push(`${prefix}${round(x)} ${round(y)}`)\n    lastCommand = 'L';\n  }\n}\n\nfunction round(x) {\n  return Math.round(x * 100)/100\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createSVGContext.js","import createSVGContext from './createSVGContext';\n\n/**\n * This is the core component of the website which renders lines on the overlay\n * layer\n * @param {*} appState - @see ../appState.js\n * @param {*} map  - mapbox map instance\n * @param {*} canvas  - where the lines should be rendered\n */\nexport default function createHeightMapRenderer(appState, regionInfo, canvas) {\n  let renderHandle;\n  let trueWindowHeight;\n\n  render();\n\n  return {\n    /**\n     * When new render request is created, we have to cancel the current one:\n     */\n    cancel,\n    render\n  }\n\n  function render(settings) {\n    // let's set everything up to match our application state:\n    if (appState.renderProgress) {\n      appState.renderProgress.message = 'Rendering...'\n    }\n\n    const oceanLevel = Number.parseFloat(appState.oceanLevel);\n\n    let smoothSteps = parseFloat(appState.smoothSteps);\n\n    canvas.style.opacity = appState.mapOpacity / 100;\n\n    let ctx = canvas.getContext('2d');\n    let lineStroke = getColor(appState.lineColor);\n    let lineFill = getColor(appState.lineBackground);\n    let lineWidth = Number.parseFloat(appState.lineWidth);\n\n    let resHeight = regionInfo.windowHeight;\n    let resWidth = window.innerWidth;\n    let rowCount = Math.round(resHeight * appState.lineDensity / 100); \n    let scale = appState.heightScale;\n\n    // since tiles can be partially overlapped, we use our own iterator\n    // over partially overlapped tiles (to not deal with offset math here)\n    const {minHeight, maxHeight, rowWithHighestPoint} = regionInfo.getAllHeightData();\n    const iteratorSettings = createRegionIterator(rowCount, resHeight, rowWithHighestPoint);\n\n    // we want the scale be independent from the zoom level, use the distribution\n    // of heights as our scaler:\n    let heightRange = maxHeight - minHeight;\n\n    let lastLine = [];\n    let lastRow = iteratorSettings.start;\n\n    // When rendered to SVG - count the filled area, so that we can break paths\n    // if they overlap already rendered paths\n    let columnHeights;\n    trueWindowHeight = window.innerHeight;\n\n    if (settings && settings.svg) {\n      // SVG needs hex values, not rgba, also ignore alpha\n      lineStroke = getColor(appState.lineColor, /* useHex = */ true);\n      columnHeights = new Float32Array(window.innerWidth);\n      lastRow = iteratorSettings.stop;\n      // This is going to be our look up structure. Point `(x, y)` is visible\n      // only if its `y` coordinate is smaller than `columnHeight[x]` value.\n      // (we render from bottom to top for svg files)\n      for (let x = 0; x < window.innerWidth; ++x) {\n        columnHeights[x] = trueWindowHeight; \n      }\n      return renderSVGRows(settings);\n    } else {\n      clearScene();\n      return renderRows();\n    }\n\n    // Public part is over. Below is is just implementation detail\n\n    function renderSVGRows(settings) {\n      let svg = createSVGContext(window.innerWidth, window.innerHeight); // || ctx - they both work here.\n      let row = 0;\n      let width = window.innerWidth;\n      svg.fillStyle = getColor(appState.backgroundColor, /* useHex = */ true);\n      svg.fillRect(0, 0, window.innerWidth, window.innerHeight);\n\n      for (let y = lastRow; y > 0; y -= iteratorSettings.step) {\n        drawSVGLine(lastLine, svg);\n        lastLine = [];\n        let isEven = (row % 2) === 0\n        row += 1;\n\n        for (let i = 0; i < width; i += 1) {\n          let x = isEven ? i : width - 1 - i;\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n          if (height <= oceanLevel) {\n            drawSVGLine(lastLine, svg);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y - iteratorSettings.step;\n      }\n\n      drawSVGLine(lastLine, svg);\n\n      appState.renderProgress = null;\n      if (settings && settings.labels) {\n      }\n      if (svg.serialize) {\n        svg.appendLabels(settings && settings.labels);\n        // ctx (used for debugging) doesn't have this method\n        return svg.serialize();\n      }\n    }\n\n    /**\n     * This renders rows, and stops if allowed time quota is exceeded (making rendering\n     * async, so that we do not freeze the main thread)\n     */\n    function renderRows() {\n      let now = performance.now();\n\n      for (let y = lastRow; y <= iteratorSettings.stop; y += iteratorSettings.step) {\n        drawPolyLine(lastLine, true);\n        lastLine = [];\n\n        for (let x = 0; x < window.innerWidth; ++x) {\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n\n          if (height <= oceanLevel) {\n            drawPolyLine(lastLine, true);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y + iteratorSettings.step;\n        let elapsed = performance.now() - now;\n        if (elapsed > 200) {\n          renderHandle = requestAnimationFrame(renderRows);\n          return;\n        }\n      }\n\n      drawPolyLine(lastLine, true);\n\n      appState.renderProgress = null;\n    }\n\n    /**\n     * Draws a polyline, that does not intersect already rendered\n     * lines. Assumption is that we render from bottom to the top.\n     * \n     * \n     */\n    function drawSVGLine(points, svg) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      svg.beginPath();\n      svg.strokeStyle = lineStroke;\n      svg.lineWidth = lineWidth;\n      let wasVisible = false;\n      for (let i = 0; i < points.length; i += 2) {\n        let x = points[i];\n        let y = points[i + 1];\n\n        let lastRenderedColumnHeight = columnHeights[x];\n        let isVisible = y <= lastRenderedColumnHeight && y >= 0 && y < trueWindowHeight;\n        if (isVisible) {\n          // This is important bit. We mark the entire area below as \"rendered\"\n          // so that next `isVisible` check will return false, and we will break the line\n          columnHeights[x] = Math.min(y, lastRenderedColumnHeight)\n          // the path is visible:\n          if (wasVisible) {\n            svg.lineTo(x, y);\n          } else {\n            svg.moveTo(x, y);\n          }\n        } else {\n          // The path is no longer visible\n          if (wasVisible) {\n            // But it was visible before\n            svg.lineTo(x, y < 0 ? 0 : lastRenderedColumnHeight);\n          } else {\n            svg.moveTo(x, y < 0? 0 : lastRenderedColumnHeight);\n          }\n        }\n        wasVisible = isVisible;\n      }\n      svg.stroke();\n    }\n\n    /**\n     * Draws filled polyline.\n     */\n    function drawPolyLine(points) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      // If line's height is greater than 2 pixels, let's fill it:\n      if (smoothRange.max - smoothRange.min > 2) {\n        ctx.beginPath();\n        ctx.fillStyle = lineFill;\n        ctx.moveTo(points[0], points[1]);\n        for (let i = 2; i < points.length; i += 2) {\n          ctx.lineTo(points[i], points[i + 1]);\n        }\n        ctx.lineTo(points[points.length - 2], smoothRange.max);\n        ctx.lineTo(points[0], smoothRange.max);\n        ctx.closePath();\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n      ctx.strokeStyle = lineStroke;\n      ctx.lineWidth = lineWidth;\n      ctx.moveTo(points[0], points[1]);\n      for (let i = 2; i < points.length; i += 2) {\n        ctx.lineTo(points[i], points[i + 1]);\n      }\n      ctx.stroke();\n    }\n\n    function clearScene() {\n      ctx.beginPath();\n      ctx.clearRect(0, 0, resWidth, resHeight);\n      ctx.fillStyle = getColor(appState.backgroundColor);\n      ctx.fillRect(0, 0, resWidth, resHeight);\n    }\n  }\n\n  function cancel() {\n    cancelAnimationFrame(renderHandle)\n    appState.renderProgress = null;\n  }\n\n  /**\n   * Simple smoothing function with moving averages, augmented with\n   * min/max calculation (don't want to spend more CPU cycles fo min/max)\n   */\n  function getSmoothRange(points, windowSize) {\n    let result = [];\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n    let length = points.length / 2;\n    for (let i = 0; i < length; i += 1) {\n      const leftOffset = i - windowSize;\n      const from = leftOffset >= 0 ? leftOffset : 0\n      const to = i + windowSize + 1;\n\n      let count = 0\n      let sum = 0\n      for (let j = from; j < to && j < length; j += 1) {\n        sum += points[2 * j + 1]\n        count += 1\n      }\n\n      let smoothHeight = sum / count;\n      result[2 * i] = points[2 * i];\n      result[2 * i + 1] = smoothHeight;\n\n      if (max < smoothHeight) max = smoothHeight;\n      if (min > smoothHeight) min = smoothHeight;\n    }\n\n    return {\n      points: result,\n      min,\n      max\n    };\n  }\n\n  /**\n   * Iterate over height map.\n   */\n  function createRegionIterator(rowCount, resHeight, includeRowIndex) {\n    let stepSize = Math.round(resHeight / rowCount);\n    let start = includeRowIndex - Math.floor(includeRowIndex/stepSize) * stepSize;\n    let stop = start + stepSize * Math.floor((resHeight - start) / stepSize)\n\n    return {\n      start,\n      stop,\n      step: stepSize,\n    }\n  }\n\n  function getColor(color, useHex) {\n    if (useHex) {\n      return `#${hex(color.r)}${hex(color.g)}${hex(color.b)}`;\n    }\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`\n  }\n}\n\nfunction hex(x) {\n  if (x === 0) return '00';\n  let hexValue = x.toString(16)\n  return x < 16 ? '0' + hexValue : hexValue;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createHeightMapRenderer.js","export const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW52YWthIiwiYSI6ImNrNWRqcDdnNTF4MHYzbXAzNDJzODludnYifQ.2WDAbuAzUuchNtCAcZitAw';\n\n\n\n// WEBPACK FOOTER //\n// ./src/config.js","var inside = require('point-in-polygon');\nvar simplify = require('./simplify');\n\n\nexport default function indexPolygon(nominatimResponse) {\n  if (!nominatimResponse) return yes;\n  let {boundingbox} = nominatimResponse;\n\n  let tolerance = (boundingbox[3] - boundingbox[2])/1000;\n\n  let checkForGeo = yes;\n\n  if (nominatimResponse.geojson) {\n    checkForGeo = checkInsideGeoJSON(nominatimResponse.geojson);\n  }\n\n  return function isInside(lonLat) {\n    return isInsideBoundingBox(lonLat) && checkForGeo(lonLat);\n  }\n\n  function yes() { return true; }\n\n  function isInsideBoundingBox(lonLat) {\n    return !(lonLat[1] < boundingbox[0] || lonLat[1] > boundingbox[1] ||\n     lonLat[0] < boundingbox[2] || lonLat[0] > boundingbox[3]);\n\n  }\n\n\n  function checkInsideGeoJSON(poly) {\n    let coordinates = poly.coordinates;\n    if (poly.type === 'Polygon') {\n      coordinates = [coordinates];\n    } else if (poly.type === 'MultiPolygon') {\n      coordinates = poly.coordinates;\n    } else if (poly.type === 'Point') {\n      return yes;\n    } else { \n      throw new Error('Unsupported polygon type ' + poly.type);\n    }\n\n    let polygons = coordinates.map(polygon => {\n      let final = simplify(polygon[0], tolerance);\n      return final;\n    });\n\n    return function isInsideGeoJSON(lonLat) {\n      for (let i = 0; i < polygons.length; ++i) {\n        if (inside(lonLat, polygons[i])) return true;\n      }\n\n      return false;\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/indexPolygon.js","import { MAPBOX_TOKEN } from \"./config\";\nimport indexPolygon from \"./lib/indexPolygon\";\n\nconst apiURL = `https://api.mapbox.com/v4/mapbox.terrain-rgb/zoom/tLong/tLat@2x.pngraw?access_token=${MAPBOX_TOKEN}`;\nlet imageCache = new Map();\n\nexport default function getRegionElevation(map, appState, doneCallback) {\n  const progress = appState.renderProgress || {};\n\n  const {tileSize, tileZoom} = map.transform;\n  const zoomPower = Math.pow(2, tileZoom);\n\n  const coveringTiles = map.transform.coveringTiles({\n    minzoom: tileZoom,\n    maxzoom: tileZoom,\n    tileSize\n  });\n\n  const tileBounds = getTilesBounds(coveringTiles);\n  const widthInTiles = tileBounds.maxX - tileBounds.minX;\n  const heightInTiles = tileBounds.maxY - tileBounds.minY;\n  if (widthInTiles > 50 || heightInTiles > 50) throw new Error('Too many tiles requested. How did you do it?');\n  let windowHeight = window.innerHeight;\n\n  if (!map.transform.angle && !map.transform.bearing) {\n    // give a little bit of buffer at the bottom if possible\n    let se = map.getBounds().getSouthEast();\n    se.lat = tile2lat(tileBounds.maxY + 1, zoomPower);\n    windowHeight = Math.floor(map.project(se).y);\n  }\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = (widthInTiles + 1) * tileSize;\n  canvas.height = (heightInTiles + 1) * tileSize;\n\n  const ctx = canvas.getContext('2d');\n\n  const minX = tileBounds.minX;\n  const minY = tileBounds.minY;\n\n  progress.total = coveringTiles.length;\n\n  advanceProgress();\n\n  let heightsHandle;\n  let isCancelled = false;\n  const tilesToLoad = coveringTiles.map(toLoadedTile);\n\n  Promise.all(tilesToLoad)\n    .then(computeVisibleHeights)\n    .then(createAPI)\n    .then(api => {\n      if (!isCancelled) {\n        doneCallback(api)\n      }\n    });\n\n  return {\n    cancel() {\n      isCancelled = true;\n      cancelAnimationFrame(heightsHandle);\n    }\n  }\n\n  function createAPI(visibleHeights) {\n    let width = visibleHeights.windowWidth;\n    let allHeights = visibleHeights.allHeights;\n\n    return {\n      getHeightAtPoint,\n      windowHeight,\n      getAllHeightData() {\n        return visibleHeights;\n      }\n    };\n\n    function getHeightAtPoint(x, y) {\n      return allHeights[x + y * width];\n    }\n  }\n\n  function computeVisibleHeights() {\n    progress.message = 'Computing elevation lines...';\n\n    const canvasWidth = canvas.width;\n    const data = ctx.getImageData(0, 0, canvasWidth, canvas.height).data;\n    const windowWidth = window.innerWidth;\n    let allHeights = new Float32Array(windowWidth * windowHeight);\n    let done;\n\n    let timeQuota = 16;\n    let minHeight = Infinity;\n    let maxHeight = -Infinity;\n    let rowWithHighestPoint = -1;\n    let lastY = 0;\n\n    let insideMask = indexPolygon(appState.bounds);\n    heightsHandle = requestAnimationFrame(collectHeights); // todo let it be cancelled;\n\n    return new Promise((resolve) => { done = resolve });\n\n    function collectHeights() {\n      let startTime = window.performance.now();\n      let rowsProcessed = 0;\n\n      for (let y = lastY; y < windowHeight; ++y) {\n        for (let x = 0; x < windowWidth; ++x) {\n          const index = y * windowWidth + x;\n          const height = getHeight(x, y, insideMask);\n          allHeights[index] = height;\n          if (height < minHeight) minHeight = height;\n          if (height > maxHeight) {\n            maxHeight = height;\n            rowWithHighestPoint = y;\n          }\n        }\n        rowsProcessed += 1;\n        let elapsed = window.performance.now() - startTime;\n        if (elapsed > timeQuota && rowsProcessed > 3) {\n          if (!isCancelled) heightsHandle = requestAnimationFrame(collectHeights);\n          progress.message = 'Computing elevation lines... ' + Math.round(100 * y/windowHeight) + '%';\n          return;\n        }\n        lastY = y;\n      }\n\n      done({\n        minHeight, maxHeight, \n        rowWithHighestPoint, \n        allHeights,\n        windowWidth,\n        windowHeight\n      });\n    }\n\n    function getHeight(x, y, insideMask) {\n      let lngLat = map.transform.pointLocation({x, y})\n      if (!insideMask([lngLat.lng, lngLat.lat])) return -20;\n\n      let xTile = lng2tile(lngLat.lng, zoomPower);\n      let xOffset = (xTile - minX) * tileSize;\n      let yTile = lat2tile(lngLat.lat, zoomPower);\n      let yOffset = (yTile - minY) * tileSize;\n      let yC = Math.round(yOffset);\n      let xC = Math.round(xOffset);\n\n      let index = (yC * canvasWidth + xC) * 4;\n      let R = data[index + 0];\n      let G = data[index + 1];\n      let B = data[index + 2];\n\n      return decodeHeight(R, G, B)\n    }\n\n    function decodeHeight(R, G, B) {\n      let height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)\n      if (height < -100) {\n        // Fiji islands data has huge caves, which pushes the entire thing up.\n        // I'm reducing it.\n        height = height / 5000;\n      }\n      return height;\n    }\n  }\n\n  function toLoadedTile(tile) {\n    const request = getRequestForTile(tile);\n\n    return loadImage(request.url)\n      .then(drawTileImage)\n      .catch(drawBlankTile)\n      .finally(advanceProgress);\n\n    function drawTileImage(image) {\n      ctx.drawImage(image, request.x, request.y);\n    }\n\n    function drawBlankTile() {\n      ctx.beginPath();\n      ctx.fillStyle = '#0186a0'; // zero height\n      ctx.fillRect(request.x, request.y, tileSize, tileSize);\n    }\n  }\n\n  function getRequestForTile(tile) {\n    const p = tile.canonical;\n    const url = apiURL\n      .replace('zoom', p.z)\n      .replace('tLat', p.y)\n      .replace('tLong', p.x);\n\n    return {\n      url,\n      x: tileSize * (p.x - tileBounds.minX), \n      y: tileSize * (p.y - tileBounds.minY)\n    }\n  }\n\n  function advanceProgress() {\n    if (progress.completed === undefined) {\n      progress.completed = -1;\n    }\n    progress.completed = Math.min(progress.total, progress.completed + 1);\n    progress.message = `Downloading tiles: ${progress.completed} of ${progress.total}...`\n  }\n  \n}\n\nfunction lng2tile(l, zoomPower) {\n  let result = ((l + 180) / 360) * zoomPower;\n  return result;\n}\n\nfunction lat2tile(l, zoomPower) {\n  let angle = l * Math.PI / 180;\n  return (\n    ((1 - Math.log( Math.tan(angle) + 1 / Math.cos(angle)) /\n        Math.PI) /\n      2) * zoomPower \n  );\n}\n\nfunction tile2lat(y, zoomPower) {\n  let n = Math.PI - 2 * Math.PI * y / zoomPower;\n  return 180 / Math.PI * Math.atan(0.5*(Math.exp(n)-Math.exp(-n)));\n}\n\nfunction loadImage(url) {\n  let cachedImage = imageCache.get(url);\n  if (!cachedImage) {\n    cachedImage = new Promise((resolve, error) => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(img);\n      };\n      img.onerror = error;\n      img.crossOrigin = \"anonymous\";\n      img.src = url;\n    });\n    imageCache.set(url, cachedImage);\n  }\n\n  return cachedImage;\n}\n\nfunction getTilesBounds(tiles) {\n  return tiles.reduce((bounds, tile) => {\n    let p = tile.canonical;\n    if (bounds.minX > p.x) bounds.minX = p.x;\n    if (bounds.minY > p.y) bounds.minY = p.y;\n    if (bounds.maxX < p.x) bounds.maxX = p.x;\n    if (bounds.maxY < p.y) bounds.maxY = p.y;\n\n    return bounds;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/getRegionElevation.js","/**\n * This is the website startup point.\n */\nimport appState from \"./appState\";\nimport mapboxgl from \"mapbox-gl\";\nimport createHeightMapRenderer from \"./lib/createHeightMapRenderer\";\nimport { MAPBOX_TOKEN } from \"./config\";\nimport getRegionElevation from './getRegionElevation';\n\nvar MapboxGeocoder = require(\"@mapbox/mapbox-gl-geocoder\");\nwindow.addEventListener('error', logError);\n\n// Load vue asyncronously\nrequire.ensure(\"@/vueApp.js\", () => {\n  require(\"@/vueApp.js\");\n});\n\n// Hold a reference to mapboxgl instance.\nlet map;\nlet heightMapRenderer;\nlet regionBuilder;\nlet isListening = false;\n// Let the vue know what to call to start the app.\nappState.init = init;\nappState.redraw = redraw;\nappState.updateMap = updateMap;\nappState.exportToSVG = exportToSVG;\nappState.setBounds = setBounds;\nappState.listenToEvents = listenToEvents;\n\nfunction init() {\n  updateSizes();\n\n  mapboxgl.accessToken = MAPBOX_TOKEN;\n\n  window.map = map = new mapboxgl.Map({\n    trackResize: false,\n    container: \"map\",\n    minZoom: 0,\n    style: \"mapbox://styles/mapbox/light-v10\",\n    center: [-122.574, 47.727],\n    zoom: 7.68,\n    hash: true\n  });\n\n  map.addControl(\n    new mapboxgl.NavigationControl({ showCompass: false }),\n    \"bottom-right\"\n  );\n  map.addControl(new MapboxGeocoder({ accessToken: mapboxgl.accessToken }));\n  listenToEvents(true);\n\n  map.on(\"load\", function() {\n    appState.angle = map.getBearing();\n  });\n\n  // map.dragRotate.disable();\n  map.touchZoomRotate.disableRotation();\n}\n\nfunction listenToEvents(newIsListening) {\n  if (newIsListening) {\n    if (!isListening) {\n      map.on('moveend', updateMapWhenIdle);\n      map.on('movestart', hideHeights);\n    }\n    isListening = true;\n  } else {\n    map.off('moveend', updateMapWhenIdle);\n    map.off('movestart', hideHeights);\n  }\n}\n\nfunction updateMapWhenIdle() {\n  map.once('idle', updateMap)\n}\n\nfunction hideHeights() {\n  appState.zazzleLink = null;\n  let canvas = getHeightMapCanvas();\n  if (canvas) canvas.style.opacity = 0.02;\n}\n\nfunction redraw() {\n  if (!heightMapRenderer) return;\n\n  ensureSizeIsUpdated();\n  heightMapRenderer.cancel();\n  heightMapRenderer.render();\n}\n\nfunction exportToSVG(settings) {\n  if (!heightMapRenderer) return;\n  return heightMapRenderer.render(Object.assign({\n    svg: true,\n  }, settings));\n}\n\nfunction updateMap() {\n  if (!map) return;\n\n  let heightMapCanvas = getHeightMapCanvas();\n  if (!heightMapCanvas) return;\n\n  ensureSizeIsUpdated();\n\n  if (heightMapRenderer) {\n    heightMapRenderer.cancel();\n  }\n  if (regionBuilder) {\n    regionBuilder.cancel();\n  }\n\n  if (!appState.shouldDraw) {\n    heightMapCanvas.style.display = \"none\";\n    return;\n  } else {\n    heightMapCanvas.style.display = \"\";\n  }\n  \n  appState.renderProgress = {\n    message: '',\n    isCancelled: false,\n    completed: false\n  };\n\n  // This will fetch all heightmap tiles\n  regionBuilder = getRegionElevation(map, appState,  showRegionHeights)\n\n  function showRegionHeights(regionInfo) {\n    heightMapRenderer = createHeightMapRenderer(appState, regionInfo, heightMapCanvas);\n  }\n}\n\nfunction setBounds(bounds) {\n  appState.bounds = bounds;\n  if (bounds) {\n    appState.selectedBoundShortName = bounds.display_name;\n    appState.mapName = (bounds.display_name || '').split(',')[0]\n    const bbox = bounds.boundingbox;\n\n    map.fitBounds([[bbox[2], bbox[1]], [bbox[3], bbox[0]]], {\n      animate: false,\n      padding: {\n        top: 42,\n        bottom: 0,\n        left: 0,\n        right: 0\n      }\n    })\n  } else {\n    appState.selectedBoundShortName = null;\n    appState.mapName = '';\n  }\n  updateMap();\n}\n\nfunction ensureSizeIsUpdated() {\n  if (!appState.sizeDirty) return;\n  appState.sizeDirty = false;\n  updateSizes();\n}\n\nfunction updateSizes() {\n  let dimensions = getCanvasDimensions();\n  let mapContainer = getMapContainer();\n  if (mapContainer) {\n    mapContainer.style.left = px(dimensions.left);\n    mapContainer.style.top = px(dimensions.top);\n    mapContainer.style.width = px(dimensions.width);\n    mapContainer.style.height = px(dimensions.height);\n  }\n  if (map) {\n    map.resize();\n  }\n\n  const heightMapCanvas = getHeightMapCanvas();\n  if (heightMapCanvas) {\n    heightMapCanvas.width = dimensions.width;\n    heightMapCanvas.height = dimensions.height;\n    heightMapCanvas.style.left = px(dimensions.left);\n    heightMapCanvas.style.top = px(dimensions.top);\n    heightMapCanvas.style.width = px(dimensions.width);\n    heightMapCanvas.style.height = px(dimensions.height);\n  }\n\n  appState.sizeDirty = false;\n}\n\nfunction getHeightMapCanvas() {\n  return document.querySelector('.height-map')\n}\nfunction getMapContainer() {\n  return document.querySelector('#map');\n}\n\nfunction getCanvasDimensions() {\n  return {\n    left: 0,\n    top: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n}\n\nfunction logError(e) {\n  if (typeof gtag === 'undefined') return;\n\n  const exDescription = e ? `${e.message} in ${e.filename}:${e.lineno}` : 'Unknown exception';\n\n  gtag('send', 'exception', {\n    description: exDescription,\n    fatal: false\n  });\n}\n\nfunction px(x) {\n  return x + 'px';\n}\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}